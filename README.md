# Genome Assembly from Short Reads with Python

## Overview
This tool assembles a long DNA sequence from short DNA reads produced by sequencing technologies. Using computational methods, it:

- Constructs a **de Bruijn graph** from the input DNA fragments (k-mers).
- Traverses the graph to find an **Eulerian cycle**, predicting the most probable sequence.
- Outputs the reconstructed DNA sequence as a text file.

This tool is ideal for genome assembly tasks in bioinformatics and computational biology.

---

## Background

### Genome Assembly: A Computational Challenge
Genome assembly is a critical process in bioinformatics where fragmented DNA sequences, generated by sequencing technologies, are computationally pieced together to reconstruct the original long DNA molecule. This process is foundational in understanding genetic information, enabling applications such as disease research, evolutionary studies, and synthetic biology.

Modern DNA sequencing technologies, such as Illumina and Oxford Nanopore, generate vast amounts of short DNA fragments, or reads, because reading entire genomes directly is not feasible due to biological and technical constraints. These reads overlap and often include errors or missing data, making the assembly process computationally challenging.

### Role of Graph Theory in Genome Assembly
To tackle the assembly problem, computational methods leverage graph theory. This project employs a de Bruijn graph approach, where:
- Nodes represent \(k-1\) prefixes and suffixes of \(k\)-mers, substrings of DNA of length \(k\).
- Directed edges connect overlapping \(k\)-mers, capturing the structure of the DNA sequence.

The task then reduces to finding an Eulerian cycle—a path that visits every edge exactly once—within this graph. This cycle represents the reconstructed DNA sequence.

### Advantages of the de Bruijn Graph Approach
- **Efficiency**: The de Bruijn graph compresses redundant information, making it scalable for large datasets.
- **Robustness**: It handles sequencing errors and overlaps effectively by focusing on shared \(k\)-mer patterns.
- **Widespread Application**: The method underpins many modern genome assemblers, proving its reliability in both research and industry.

### Limitations and Considerations
While effective, this approach is sensitive to the choice of \(k\)-mer size. A smaller \(k\) leads to excessive overlaps and ambiguities, whereas a larger \(k\) may fragment the graph due to insufficient overlap information. Balancing \(k\) is crucial for optimal assembly quality.

---

## Features
1. **Input**: Accepts DNA sequencing data in FASTQ format.
2. **Processing**:
   - Generates k-mers.
   - Builds a de Bruijn graph.
   - Identifies an Eulerian cycle.
3. **Output**: Saves the reconstructed DNA sequence to a text file.

---

## Input
- **FASTQ File**: The input file should contain DNA sequencing reads in the FASTQ format, which includes:
  - Sequence headers.
  - DNA sequences.
  - Quality scores.
  Sample FASTQ files are given in this repository.

## Output
- **Text File**: The reconstructed DNA sequence is saved as a text file in the same directory as the input FASTQ file.

---

## Installation

### Prerequisites
- Python **3.7+** installed on your system.

### Clone the Repository
```bash
git clone https://github.com/Stavoh/GASM_SR_Py.git
cd GASM_SR_Py
```

### Install Dependencies
```bash
pip install -r requirements.txt
```

---

## Usage

### Running the Program
1. Prepare your input FASTQ file. Sample files can be found in the current repository.
2. Run the program from the command line:
   ```bash
   python GASM.py <path_to_fastq_file>
   ```
4. The output file with the reconstructed DNA sequence will appear in the same directory as the input file.

### Example
```bash
python GASM.py Sample1.fastq
```
Output:
```
DNA sequence saved to: data/Sample1_Sequence_1672531200.txt
```

---

## Testing

### Running Tests
```bash
pytest
```

---

## Contributing
Contributions are welcome! Please fork the repository and submit a pull request with your changes.

---

## License
This project is licensed under the MIT License. See the `LICENSE` file for details.

## Mentions
This tool was created as part of the [WIS Python programming course](https://github.com/szabgab/wis-python-course-2024-11.git)
